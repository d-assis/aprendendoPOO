Aula 1 - Introdução e histórico
    POO == Programação orientada a objetos
        Filosofia de desenvolvimento que tem como objetivo aproximar o mundo digital do mundo real através do conceito de objetos.

    Evolução da Programação
        programação de baixo nível (linguagem de máquina) > programação linear > programação estruturada > programação modular > programação orientada a objetos

    Criador da POO
        Alan kay, biólogo e matemático

    Postulado de Alan kay
        "o computador ideal deveria funcionar como um organismo vivo, isto é, cada "célula" comportar-se-ia relacionando-se com outras a fim de alcançar um objetivo, contudo, funcionando de forma autônoma. As células poderiam também reagrupar-se para resolver um outro problema ou desempenhar outras funções."

    Vantagens da POO
        C.onfiável
            O isolamento entre as partes gera software seguro. Ao alterar uma parte, nenhuma outra é afetada.
        O.portuno
            Ao dividir tudo em partes, várias delas podem ser desenvolvidas em paralelo
        M.anutenível
            Atualizar um software é mais fácil. Uma pequena modificação vai beneficiar todas as partes que usarem o objeto.
        E.xtensível
            O software não é estático. Ele deve crescer para permanecer útil 
        R.eutilizável
            Podemos usar objetos de um sistema que criamos em outro sistema futuro
        N.atural
            Mais fácil de entender. Você se preocupa mais na funcionalidade do que nos detalhes de implementação

Aula 2 - O que são objetos
    Definição de objeto
        Coisa material ou abstrata que pode ser percebida pelos sentidos e descrita por meio das suas características, comportamentos e estado atual.

    Definição de atributos
        Características do objeto, coisas que ele tem

    Definição de métodos
        ações que o objeto pode realizar, coisas que ele faz

    Definição de estado
        estado atual de um objeto

    Definição de classe
        é análogo a um molde, ou forma que serve como base para criar (instanciar) objetos.

    Exemplo de classe 
        Classe Caneta
            // atributos
            modelo: Caractere
            cor: Caractere
            ponta: Real
            carga: Inteiro
            tampada: Logico
            
            // métodos
            Metodo rabiscar()
                Se(tampada == verdadeiro) entao
                    Escreva("ERRO")
                senao
                    Escreva("rabisco")
                FimSe
            FimMetodo

            Metodo tampar()
                tampada = verdadeiro
            FimMetodo
        FimClasse

        Exemplo de objeto instanciado 
        objeto Caneta
            // atributos
            modelo: BIC cristal
            cor: Azul
            ponta: 0.5
            carga: 100
            tampada: falso

            // métodos
            Rabiscar()
            Tampar()

            // estado
            Destampada
            Azul
            100% de carga

        Exemplo de intanciamento
            c1 = nova Caneta
            c1.cor = "Azul"
            c1.ponta = 0.5
            c1.tampada = falso
            c1.rabiscar()

            c2 = nova Caneta
            c2.cor = "Vermelho"
            c2.ponta = 1.0
            c2.tampada = falso
            c2.tampar()

Aula 3 - Visibilidade de um objeto

    linguagem de modelagem unificada (L.M.U, U.M.L ou diagrama de classes)
        Trata-se de uma estrutura super simplificada para a criação de classes dentro da POO.
        o exemplo de classe da aula 1 representa bem o conceito

    Modificadores de Visibilidade
        Indicam o nível de acesso aos componentes internos de uma classe.
        + representa visibilidade pública
            classe atual e todas as outras classes possuem acesso ao componente
        - representa visibilidade privada
            somente a classe atual possui acesso ao componente
        # representa visibilidade protegida
            classe atual e todas as suas subclasses possuem acesso ao componente

    Exemplo de declaração de classe com visibilidade
        Classe Caneta
            Publico modelo: Caractere
            Publico cor: Caractere
            Privado ponta: Real
            Protegido carga: Inteiro
            Protegido tampada: Logico

            Publico Metodo escrever()
            FimMetodo

            Publico Metodo rabiscar()
            FimMetodo

        FimClasse
    
    Manipulação da classe declarada
        c1 = nova Caneta
        c1.modelo = "BIC cristal"
        c1.cor = "Azul"
        c1.ponta = 0.5 //linha inválida, o atributo manipulado é privado, necessita de um método acessor
        c1.carga = 80 // linha inválida, o atributo manipulado é protegido, necessita de um método acessor

Aula 4 - métodos especiais
    Métodos acessores (getters)
        métodos especiais responsáveis por dar acesso ou "pegar" informações de um objeto
        ex.:
        e = nova Estante
        t = e.getTotDoc

    Métodos modificadores (setters)
        métodos especiais responsáveis por fazer alterações nas informações de um objeto
        ex.:
        e = nova Estante
        t = e.setTotDoc(doc)

    Métodos construtores (construct)
        métodos especiais responsáveis por executar ações diversas no momento do instanciamento de um objeto

    Exemplo de definição de métodos especiais numa classe
        Classe Caneta
            publico modelo: Caractere
            privado ponta: Real
            publico cor: Caractere
            publico tampada: Logico

            publico Metodo getModelo()
                retorne modelo
            FimMetodo

            publico Metodo setModelo(m: caractere)
                modelo = m
            FimMetodo

            publico Metodo getPonta(p)
                retorne ponta
            FimMetodo

            publico Metodo setPonta(p: Real)
                ponta = p
            FimMetodo

            publico Metodo tampar()
                tampada = verdadeiro
            FimMetodo

            publico Metodo construtor(m: Caractere, c: Caractere, p: Real)
                setModelo(m)
                setCor(c)
                setPonta(p)
                tampar()
            FimMetodo
        FimClasse

        c1 = nova Caneta
        c1.setModelo("BIC Cristal")
        c1.setPonta(0.5)
        Escreva(c1.getModelo())
        Escreva(c1.getPonta())

        c2 = nova Caneta("BIC","Azul", 0.5)

Aula 6a - Pilares da POO (encapsulamento)
    Encapsular
        Ocultar partes independentes da implementação, permitindo construir partes invisíveis ao mundo exterior.
        Encapsular não é obrigatório, mas é uma boa prática para produzir classes mais eficientes.

    Vantagens de encapsulamento
        1- tornar mudanças invisíveis

        2- facilitar reutilização de código

        3- reduzir efeitos colaterais

    Interface
        Lista de serviços fornecidos por um componente. É o contato com o mundo exterior, que define o que pode ser feito com um objeto dessa classe.

Aula 7a - Relacionamento entre classes

Aula 8a - Relacionamento entre classes (parte 2)
    representando relacionamento no diagrama
        Para representar a relação de agregação num diagrama de classes, utiliza-se uma linha sólida partindo de uma das classes e dirigindo-se para um losango posicionado sobre a segunda classe.
        (imagem 8a1)
    representando multiplicidade
        (imagem 8a2)
    representando papel e sentido
        (imagem 8a2)
    Relação de agregação
        uma relação de agregação entre partes pressupõe que uma parte contém outra.
        ex.: A classe luta *tem um* lutador (instância da classe Lutador) participante 

Aula 10a - Herança (pt1)
    Conceito de Herança
        Permite basear uma nova classe na definição de uma outra classe previamente existente.
        A herança será aplicada tanto para características quanto para os comportamentos.

    Representação de herança no diagrama
        imagem 10a1

Aula 11a - Herança (pt2)
    Termos da árvore de herança
        *vide imagem 11a1
        Raiz: classe que origina todas as subclasses e não possui superclasse

        folha: qualquer classe originada apartir de uma superclasse e que não possua subclasses

        descendente: subclasses geradas apartir de um filho de uma superclasse, classes "netas", "bisnetas" e adiante

        ancestral: superclasses com "netas" e adiante 

        especialização: percorrer a árvore de herança partindo das superclasses em direção às subclasses

        generalização: percorrer a árvore de herança partindo das subclasses em direção às superclasses

    Tipos de herança
        Herança de implementação: nesse tipo, a subclasse herdam os métodos e atributos sem qualquer diferença com relação à progenitora.

        Herança para diferença: já nesse tipo, a herança pressupõe uma adição de métodos e/ou atributos das classes filhas com relação à mãe, ou seja, as filhas possuem características e comportamentos específicos que a mãe não possui

    Mais conceitos de classe no contexto de herança
        Classe abstrata: Não pode ser instanciada. Só pode servir como progenitora

        Método abstrato: declarado mas não implementado na progenitora

        Classe final: Não pode ser herdada por outra classe. Obrigatoriamente folha.

        Método final: Não pode ser sobrescrito pelas suas subclasses. Obrigatóriamente herdado

Aula 12a - Polimorfismo (pt1)
    Definição
        Permitir que um mesmo nome represente vários comportamentos (métodos) diferentes

    Assinatura de um método
        quantidade e os tipos dos parâmetros exigidos por um método definem a sua assinatura. Vide imagem 12a1.

    Tipos de polimorfismo
        Polimorfismo de sobreposição
            Acontece quando substituímos um método de uma superclasse na sua subclasse, usando a mesma assinatura.